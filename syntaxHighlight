-- CodeEditor.lua
-- A lightweight Luau syntax-highlighting editor for Roblox

local TextService = game:GetService("TextService")

local CodeEditor = {}
CodeEditor.__index = CodeEditor

-- ======= THEME =======
local defaultTheme = {
	Background = Color3.fromRGB(18, 18, 18),
	GutterBackground = Color3.fromRGB(25, 25, 25),
	GutterText = Color3.fromRGB(120, 120, 120),
	Plain = Color3.fromRGB(212, 212, 212),
	Keyword = Color3.fromRGB(197, 134, 192),
	Builtin = Color3.fromRGB(79, 193, 255),
	String = Color3.fromRGB(206, 145, 120),
	Number = Color3.fromRGB(181, 206, 168),
	Comment = Color3.fromRGB(106, 153, 85),
	Operator = Color3.fromRGB(212, 212, 212),
	Selection = Color3.fromRGB(45, 90, 160),
}

-- ======= KEYWORDS & BUILTINS =======
local KEYWORDS = {
	["and"]=true, ["break"]=true, ["do"]=true, ["else"]=true, ["elseif"]=true, ["end"]=true, ["false"]=true,
	["for"]=true, ["function"]=true, ["if"]=true, ["in"]=true, ["local"]=true, ["nil"]=true, ["not"]=true,
	["or"]=true, ["repeat"]=true, ["return"]=true, ["then"]=true, ["true"]=true, ["until"]=true, ["while"]=true,
	-- Luau extensions
	["continue"]=true, ["type"]=true, ["typeof"]=true, ["export"]=true,
}

local BUILTINS = {
	-- common globals
	["print"]=true, ["warn"]=true, ["pairs"]=true, ["ipairs"]=true, ["next"]=true, ["require"]=true,
	["table"]=true, ["string"]=true, ["math"]=true, ["coroutine"]=true, ["task"]=true, ["os"]=true,
	-- Roblox globals
	["game"]=true, ["workspace"]=true, ["script"]=true, ["Enum"]=true, ["Instance"]=true, ["Vector3"]=true,
	["CFrame"]=true, ["UDim2"]=true, ["Color3"]=true,
}

-- ======= UTILS =======
local function rgbToHex(c: Color3): string
	return string.format("#%02X%02X%02X",
		math.floor(c.R*255 + 0.5),
		math.floor(c.G*255 + 0.5),
		math.floor(c.B*255 + 0.5)
	)
end

local function escapeRich(text: string): string
	text = string.gsub(text, "&", "&amp;")
	text = string.gsub(text, "<", "&lt;")
	text = string.gsub(text, ">", "&gt;")
	return text
end

local function span(color3: Color3, text: string): string
	return string.format('<font color="%s">%s</font>', rgbToHex(color3), text)
end

-- ======= LEXER (Luau) =======
local function lexLuau(input: string, theme)
	local i, n = 1, #input
	local out = table.create(math.floor(n * 1.2))

	local function peek(o)
		o = o or 0
		if i + o <= n then
			return string.sub(input, i + o, i + o)
		end
	end

	local function starts(str: string): boolean
		return string.sub(input, i, i + #str - 1) == str
	end

	local function push(color: Color3, raw: string)
		out[#out + 1] = span(color, escapeRich(raw))
	end

	local function pushPlain(raw: string)
		out[#out + 1] = escapeRich(raw)
	end

	while i <= n do
		local c = string.sub(input, i, i)

		-- Line comment --
		if starts("--") and not starts("--[[") then
			local j = string.find(input, "\n", i + 2, true)
			local raw = j and string.sub(input, i, j - 1) or string.sub(input, i)
			push(theme.Comment, raw)
			i = j and j or n + 1

			-- Block comment --[[ ... ]]
		elseif starts("--[[") then
			local j = string.find(input, "]]", i + 4, true)
			local raw = j and string.sub(input, i, j + 1) or string.sub(input, i)
			push(theme.Comment, raw)
			i = j and (j + 2) or (n + 1)

			-- Long string [[ ... ]]
		elseif starts("[[") then
			local j = string.find(input, "]]", i + 2, true)
			local raw = j and string.sub(input, i, j + 1) or string.sub(input, i)
			push(theme.String, raw)
			i = j and (j + 2) or (n + 1)

			-- Quoted string '...' or "..."
		elseif c == "'" or c == '"' then
			local quote = c
			local j = i + 1
			local escaped = false
			while j <= n do
				local cj = string.sub(input, j, j)
				if escaped then
					escaped = false
				else
					if cj == "\\" then
						escaped = true
					elseif cj == quote then
						break
					end
				end
				j += 1
			end
			local raw = string.sub(input, i, math.min(j, n))
			push(theme.String, raw)
			i = (j < n and j + 1) or (n + 1)

			-- Number
		elseif (c:match("%d")) or (c == "." and peek(1) and string.sub(input, i + 1, i + 1):match("%d")) then
			local j = i
			if starts("0x") or starts("0X") then
				j = i + 2
				while j <= n and string.sub(input, j, j):match("[%da-fA-F]") do j += 1 end
			else
				while j <= n and string.sub(input, j, j):match("%d") do j += 1 end
				if j <= n and string.sub(input, j, j) == "." then
					j += 1
					while j <= n and string.sub(input, j, j):match("%d") do j += 1 end
				end
				if j <= n and string.sub(input, j, j):lower() == "e" then
					j += 1
					if j <= n and string.sub(input, j, j):match("[+-]") then j += 1 end
					while j <= n and string.sub(input, j, j):match("%d") do j += 1 end
				end
			end
			local raw = string.sub(input, i, j - 1)
			push(theme.Number, raw)
			i = j

			-- Identifier / keyword / builtin
		elseif c:match("[%a_]") then
			local j = i + 1
			while j <= n and string.sub(input, j, j):match("[%w_]") do j += 1 end
			local raw = string.sub(input, i, j - 1)
			if KEYWORDS[raw] then
				push(theme.Keyword, raw)
			elseif BUILTINS[raw] then
				push(theme.Builtin, raw)
			else
				pushPlain(raw)
			end
			i = j

			-- Operators & punctuation (two-char first)
		elseif i < n then
			local two = string.sub(input, i, i + 1)
			if two == "==" or two == "~=" or two == "<=" or two == ">=" or
				two == ".." or two == "::" or two == "//" then
				push(theme.Operator, two)
				i += 2
			else
				if c:match("[%+%-%*%%%/%^%#%=%<%>%(%)]") or c:match("[%{%}%[%]:;%,%.]") then
					push(theme.Operator, c)
				else
					-- whitespace (tab/newline/space)
					if c == "\t" then
						pushPlain("\t")
					else
						pushPlain(c)
					end
				end
				i += 1
			end
		else
			-- last single char
			if c:match("[%+%-%*%%%/%^%#%=%<%>%(%)]") or c:match("[%{%}%[%]:;%,%.]") then
				push(theme.Operator, c)
			else
				pushPlain(c)
			end
			i += 1
		end
	end

	return table.concat(out)
end

-- ======= MISC =======
local function countLines(text: string): number
	local _, cnt = string.gsub(text, "\n", "")
	return cnt + 1
end

-- ======= UI CREATION =======
local function makeUI(parent: Instance, theme, textSize: number, font: Enum.Font, paddingLeft: number)
	local root = Instance.new("Frame")
	root.Name = "CodeEditor"
	root.BackgroundColor3 = theme.Background
	root.BorderSizePixel = 0
	root.Size = UDim2.new(1, 0, 1, 0)
	root.Parent = parent

	local scroll = Instance.new("ScrollingFrame")
	scroll.Name = "Scroll"
	scroll.BackgroundTransparency = 1
	scroll.BorderSizePixel = 0
	scroll.Position = UDim2.fromOffset(0, 0)
	scroll.Size = UDim2.fromScale(1, 1)
	scroll.ScrollBarImageTransparency = 0
	scroll.ScrollBarThickness = 10
	scroll.TopImage = "rbxasset://textures/ui/Scroll/scroll-middle.png"
	scroll.BottomImage = "rbxasset://textures/ui/Scroll/scroll-middle.png"
	scroll.Parent = root

	local gutter = Instance.new("TextLabel")
	gutter.Name = "Gutter"
	gutter.BackgroundColor3 = theme.GutterBackground
	gutter.BorderSizePixel = 0
	gutter.TextColor3 = theme.GutterText
	gutter.Font = font
	gutter.TextSize = textSize
	gutter.TextXAlignment = Enum.TextXAlignment.Right
	gutter.TextYAlignment = Enum.TextYAlignment.Top
	gutter.TextWrapped = false
	gutter.RichText = false
	gutter.ZIndex = 1
	gutter.Parent = scroll

	local high = Instance.new("TextLabel")
	high.Name = "Highlighter"
	high.BackgroundTransparency = 1
	high.BorderSizePixel = 0
	high.TextColor3 = defaultTheme.Plain
	high.Font = font
	high.TextSize = textSize
	high.TextXAlignment = Enum.TextXAlignment.Left
	high.TextYAlignment = Enum.TextYAlignment.Top
	high.TextWrapped = false
	high.RichText = true
	high.ZIndex = 4
	high.Parent = scroll

	local input = Instance.new("TextBox")
	input.Name = "Input"
	input.BackgroundTransparency = 1
	input.BorderSizePixel = 0
	input.Text = ""
	input.ClearTextOnFocus = false
	input.MultiLine = true
	input.TextXAlignment = Enum.TextXAlignment.Left
	input.TextYAlignment = Enum.TextYAlignment.Top
	input.TextWrapped = false
	input.TextEditable = true
	input.Font = font
	input.TextSize = textSize
	input.TextColor3 = Color3.new(1, 1, 1) -- caret visible
	input.TextTransparency = 0.5
	input.RichText = false
	input.CursorPosition = -1
	input.ZIndex = 3
	input.Parent = scroll

	-- Selection color (native TextBox)
	pcall(function()
		input.SelectionHighlightColor3 = theme.Selection
	end)

	-- Padding
	local gutterPadding = Instance.new("UIPadding")
	gutterPadding.PaddingTop = UDim.new(0, 4)
	gutterPadding.PaddingRight = UDim.new(0, 6)
	gutterPadding.Parent = gutter

	local codePadding = Instance.new("UIPadding")
	codePadding.PaddingTop = UDim.new(0, 4)
	codePadding.PaddingLeft = UDim.new(0, paddingLeft)
	codePadding.Parent = high

	local inputPadding = Instance.new("UIPadding")
	inputPadding.PaddingTop = UDim.new(0, 4)
	inputPadding.PaddingLeft = UDim.new(0, paddingLeft)
	inputPadding.Parent = input

	return root, scroll, gutter, high, input
end

-- ======= CONSTRUCTOR (highlighting only) =======
function CodeEditor.new(parent: Instance, options)
	options = options or {}
	local theme = options.theme or defaultTheme
	local textSize = options.textSize or 16
	local font = options.font or Enum.Font.Code
	local leftPad = options.leftPad or 8

	local self = setmetatable({}, CodeEditor)

	self._destroyed = false
	self._theme = theme
	self._font = font
	self._textSize = textSize

	self._root, self._scroll, self._gutter, self._high, self._input =
		makeUI(parent, theme, textSize, font, leftPad)

	-- state
	self._text = ""
	self._lineHeight = TextService:GetTextSize("A", textSize, font, Vector2.new(10000, 10000)).Y
	self._gutterWidth = 0
	self._throttle = false

	-- Render helpers
	local function updateGutter()
		local lines = countLines(self._text)

		local buf = table.create(lines)
		for i = 1, lines do buf[i] = tostring(i) end
		self._gutter.Text = table.concat(buf, "\n")

		local digits = #tostring(lines)
		local sample = string.rep("9", digits)
		local w = TextService:GetTextSize(sample, self._textSize, self._font, Vector2.new(10000, 10000)).X + 10
		self._gutterWidth = math.max(32, w)

		self._gutter.Position = UDim2.fromOffset(0, 0)
		self._gutter.Size = UDim2.new(0, self._gutterWidth, 0, lines * self._lineHeight + 12)
	end

	local function updateLayout()
		local lines = countLines(self._text)
		local contentHeight = lines * self._lineHeight + 12

		self._high.Position = UDim2.fromOffset(self._gutterWidth, 0)
		self._high.Size = UDim2.new(1, -self._gutterWidth, 0, contentHeight)

		self._input.Position = UDim2.fromOffset(self._gutterWidth, 0)
		self._input.Size = UDim2.new(1, -self._gutterWidth, 1, 0)

		self._scroll.CanvasSize = UDim2.fromOffset(0, contentHeight)
	end

	local function recolorNow()
		if self._destroyed then return end
		self._high.Text = lexLuau(self._text, self._theme)
		updateGutter()
		updateLayout()
	end

	local function scheduleRecolor()
		if self._throttle then return end
		self._throttle = true
		task.defer(function()
			self._throttle = false
			recolorNow()
		end)
	end

	-- Keep highlighter & gutter in sync with TextBox
	self._input:GetPropertyChangedSignal("Text"):Connect(function()
		if self._destroyed then return end
		self._text = self._input.Text
		scheduleRecolor()
	end)

	-- Initial paint
	recolorNow()

	-- Public API
	function self:SetText(t: string?)
		if self._destroyed then return end
		self._text = t or ""
		self._input.Text = self._text
		recolorNow()
	end

	function self:GetText(): string
		return self._input.Text
	end

	function self:Focus()
		self._input:CaptureFocus()
	end

	function self:Unfocus()
		self._input:ReleaseFocus()
	end

	function self:Destroy()
		if self._destroyed then return end
		self._destroyed = true
		self._root:Destroy()
	end

	return self
end

return CodeEditor
